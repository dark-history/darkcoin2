// Copyright (c) 2018-2021 The Cash2 developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include "gtest/gtest.h"
#include "helperFunctions.h"
#include "CryptoNoteCore/Core.h"
#include "CryptoNoteCore/Currency.h"
#include "CryptoNoteCore/CryptoNoteTools.h"
#include "Logging/ConsoleLogger.h"
#include "CryptoNoteCore/CoreConfig.h"
#include "CryptoNoteCore/MinerConfig.h"
#include "Common/StringTools.h"

using namespace CryptoNote;

// Helper functions

class CryptonoteProtocol : public i_cryptonote_protocol
{
public:
  void relay_block(NOTIFY_NEW_BLOCK_request& arg) override
  {
    std::cout << "relay block" << std::endl;
  }

  void relay_transactions(NOTIFY_NEW_TRANSACTIONS_request& arg) override
  {
    std::cout << "relay transactions" << std::endl;
  }
};

// testing on_submitblock indirectly
TEST(Core, 1)
{
  Logging::ConsoleLogger logger;
  Currency currency = CurrencyBuilder(logger).currency();
  CryptonoteProtocol crpytonoteProtocol;
  core core(currency, &crpytonoteProtocol, logger);
  CoreConfig coreConfig;
  MinerConfig minerConfig;
  bool loadExisting = false;
  ASSERT_TRUE(core.init(coreConfig, minerConfig, loadExisting));

  Block genesisBlock = currency.genesisBlock();
  ASSERT_TRUE(core.set_genesis_block(genesisBlock));

  // extraNonce1And2 = 2222222258170000
  // confirm nonce = bf65552d00000000
  // confirm coinbaseTransaction1 = 015701ff1b0703029aee7cc972aee75de28a8bf4c978e1277a7ed345f78a2d033487ea23745a76891402878c8c1e54b1f207e86f4f0f1ebd35b2ed3f1374cef0578aa48add175e79a001a006029754adcb7621a703c67ae7ae880033ceaed7f799d19f4d18cd4ffa9e35dd15ebf02e024cbbc3bde5d1eb044d541c6c8a4c7d63100bdc9a6812886fa95fbb4ad95ffddc80b518025e94dd5922823e8d3bfe380ba1e6dbb7761a14fa71811e0766e2af67e13b027cc0a8a50402d7455ae3238f1858142cab478a2291b4ab432d660f05ae875b2d212deea50cfd80e8922602741dc17458b0c354ed80123fecccbe0614de623ee111191d3e67e2b67e6b6e31330103c0a7f3b8a5b9e95b29e8185b7350be4d2bca6f1ab0332117442e3bc39f03eb0210
  // confirm coinbaseTransaction2 = 000000000000000000
  // confirm previousBlockHash = 86d37fb8f37273ce08713a60d4bc8fa3e8c1531d6a80b730005e4efb5a868bec
  // confirm timestamp = 2c24b05b00000000
  // confirm merkle root = 0f31384a7f42c564c3651a02a72918f34314baaddccdeec954b7794ebac3d8cb

  std::string hexBlob = "86d37fb8f37273ce08713a60d4bc8fa3e8c1531d6a80b730005e4efb5a868becbf65552d000000002c24b05b000000000f31384a7f42c564c3651a02a72918f34314baaddccdeec954b7794ebac3d8cb015701ff1b0703029aee7cc972aee75de28a8bf4c978e1277a7ed345f78a2d033487ea23745a76891402878c8c1e54b1f207e86f4f0f1ebd35b2ed3f1374cef0578aa48add175e79a001a006029754adcb7621a703c67ae7ae880033ceaed7f799d19f4d18cd4ffa9e35dd15ebf02e024cbbc3bde5d1eb044d541c6c8a4c7d63100bdc9a6812886fa95fbb4ad95ffddc80b518025e94dd5922823e8d3bfe380ba1e6dbb7761a14fa71811e0766e2af67e13b027cc0a8a50402d7455ae3238f1858142cab478a2291b4ab432d660f05ae875b2d212deea50cfd80e8922602741dc17458b0c354ed80123fecccbe0614de623ee111191d3e67e2b67e6b6e31330103c0a7f3b8a5b9e95b29e8185b7350be4d2bca6f1ab0332117442e3bc39f03eb02102222222258170000000000000000000000";

  BinaryArray blockBlob;
  ASSERT_TRUE(Common::fromHex(hexBlob, blockBlob));
  bool controlMiner = true;
  bool relayBlock = false;
  block_verification_context bvc;

  ASSERT_TRUE(core.handle_incoming_block_blob(blockBlob, bvc, controlMiner, relayBlock));
}

// getBinaryArrayHash()
TEST(RpcServer, 2)
{
  BinaryArray binaryArray = 
  {
    0x00, 0x01, 0x57, 0x01, 0xff, 0x1b, 0x07, 0x03, 0x02, 0x9a,
    0xee, 0x7c, 0xc9, 0x72, 0xae, 0xe7, 0x5d, 0xe2, 0x8a, 0x8b,
    0xf4, 0xc9, 0x78, 0xe1, 0x27, 0x7a, 0x7e, 0xd3, 0x45, 0xf7,
    0x8a, 0x2d, 0x03, 0x34, 0x87, 0xea, 0x23, 0x74, 0x5a, 0x76,
    0x89, 0x14, 0x02, 0x87, 0x8c, 0x8c, 0x1e, 0x54, 0xb1, 0xf2,
    0x07, 0xe8, 0x6f, 0x4f, 0x0f, 0x1e, 0xbd, 0x35, 0xb2, 0xed,
    0x3f, 0x13, 0x74, 0xce, 0xf0, 0x57, 0x8a, 0xa4, 0x8a, 0xdd,
    0x17, 0x5e, 0x79, 0xa0, 0x01, 0xa0, 0x06, 0x02, 0x97, 0x54,
    0xad, 0xcb, 0x76, 0x21, 0xa7, 0x03, 0xc6, 0x7a, 0xe7, 0xae,
    0x88, 0x00, 0x33, 0xce, 0xae, 0xd7, 0xf7, 0x99, 0xd1, 0x9f,
    0x4d, 0x18, 0xcd, 0x4f, 0xfa, 0x9e, 0x35, 0xdd, 0x15, 0xeb,
    0xf0, 0x2e, 0x02, 0x4c, 0xbb, 0xc3, 0xbd, 0xe5, 0xd1, 0xeb,
    0x04, 0x4d, 0x54, 0x1c, 0x6c, 0x8a, 0x4c, 0x7d, 0x63, 0x10,
    0x0b, 0xdc, 0x9a, 0x68, 0x12, 0x88, 0x6f, 0xa9, 0x5f, 0xbb,
    0x4a, 0xd9, 0x5f, 0xfd, 0xdc, 0x80, 0xb5, 0x18, 0x02, 0x5e,
    0x94, 0xdd, 0x59, 0x22, 0x82, 0x3e, 0x8d, 0x3b, 0xfe, 0x38,
    0x0b, 0xa1, 0xe6, 0xdb, 0xb7, 0x76, 0x1a, 0x14, 0xfa, 0x71,
    0x81, 0x1e, 0x07, 0x66, 0xe2, 0xaf, 0x67, 0xe1, 0x3b, 0x02,
    0x7c, 0xc0, 0xa8, 0xa5, 0x04, 0x02, 0xd7, 0x45, 0x5a, 0xe3,
    0x23, 0x8f, 0x18, 0x58, 0x14, 0x2c, 0xab, 0x47, 0x8a, 0x22,
    0x91, 0xb4, 0xab, 0x43, 0x2d, 0x66, 0x0f, 0x05, 0xae, 0x87,
    0x5b, 0x2d, 0x21, 0x2d, 0xee, 0xa5, 0x0c, 0xfd, 0x80, 0xe8,
    0x92, 0x26, 0x02, 0x74, 0x1d, 0xc1, 0x74, 0x58, 0xb0, 0xc3,
    0x54, 0xed, 0x80, 0x12, 0x3f, 0xec, 0xcc, 0xbe, 0x06, 0x14,
    0xde, 0x62, 0x3e, 0xe1, 0x11, 0x19, 0x1d, 0x3e, 0x67, 0xe2,
    0xb6, 0x7e, 0x6b, 0x6e, 0x31, 0x33, 0x01, 0x03, 0xc0, 0xa7,
    0xf3, 0xb8, 0xa5, 0xb9, 0xe9, 0x5b, 0x29, 0xe8, 0x18, 0x5b,
    0x73, 0x50, 0xbe, 0x4d, 0x2b, 0xca, 0x6f, 0x1a, 0xb0, 0x33,
    0x21, 0x17, 0x44, 0x2e, 0x3b, 0xc3, 0x9f, 0x03, 0xeb, 0x02,
    0x10, 0x22, 0x22, 0x22, 0x22, 0x58, 0x17, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

  Crypto::Hash hash;

  getBinaryArrayHash(binaryArray, hash);

  std::string hashStr = Common::podToHex<Crypto::Hash>(hash);

  ASSERT_EQ("13449193d3723f0a7b54d9ccffe9180dac59533db905e8dd6cd749a30b53f375", hashStr);
}

// getBinaryArrayHash()
TEST(RpcServer, 2a)
{
  // this test is different than test 2 because we added 0x00 to end of binaryArray
  BinaryArray binaryArray = 
  {
    0x00, 0x01, 0x57, 0x01, 0xff, 0x1b, 0x07, 0x03, 0x02, 0x9a,
    0xee, 0x7c, 0xc9, 0x72, 0xae, 0xe7, 0x5d, 0xe2, 0x8a, 0x8b,
    0xf4, 0xc9, 0x78, 0xe1, 0x27, 0x7a, 0x7e, 0xd3, 0x45, 0xf7,
    0x8a, 0x2d, 0x03, 0x34, 0x87, 0xea, 0x23, 0x74, 0x5a, 0x76,
    0x89, 0x14, 0x02, 0x87, 0x8c, 0x8c, 0x1e, 0x54, 0xb1, 0xf2,
    0x07, 0xe8, 0x6f, 0x4f, 0x0f, 0x1e, 0xbd, 0x35, 0xb2, 0xed,
    0x3f, 0x13, 0x74, 0xce, 0xf0, 0x57, 0x8a, 0xa4, 0x8a, 0xdd,
    0x17, 0x5e, 0x79, 0xa0, 0x01, 0xa0, 0x06, 0x02, 0x97, 0x54,
    0xad, 0xcb, 0x76, 0x21, 0xa7, 0x03, 0xc6, 0x7a, 0xe7, 0xae,
    0x88, 0x00, 0x33, 0xce, 0xae, 0xd7, 0xf7, 0x99, 0xd1, 0x9f,
    0x4d, 0x18, 0xcd, 0x4f, 0xfa, 0x9e, 0x35, 0xdd, 0x15, 0xeb,
    0xf0, 0x2e, 0x02, 0x4c, 0xbb, 0xc3, 0xbd, 0xe5, 0xd1, 0xeb,
    0x04, 0x4d, 0x54, 0x1c, 0x6c, 0x8a, 0x4c, 0x7d, 0x63, 0x10,
    0x0b, 0xdc, 0x9a, 0x68, 0x12, 0x88, 0x6f, 0xa9, 0x5f, 0xbb,
    0x4a, 0xd9, 0x5f, 0xfd, 0xdc, 0x80, 0xb5, 0x18, 0x02, 0x5e,
    0x94, 0xdd, 0x59, 0x22, 0x82, 0x3e, 0x8d, 0x3b, 0xfe, 0x38,
    0x0b, 0xa1, 0xe6, 0xdb, 0xb7, 0x76, 0x1a, 0x14, 0xfa, 0x71,
    0x81, 0x1e, 0x07, 0x66, 0xe2, 0xaf, 0x67, 0xe1, 0x3b, 0x02,
    0x7c, 0xc0, 0xa8, 0xa5, 0x04, 0x02, 0xd7, 0x45, 0x5a, 0xe3,
    0x23, 0x8f, 0x18, 0x58, 0x14, 0x2c, 0xab, 0x47, 0x8a, 0x22,
    0x91, 0xb4, 0xab, 0x43, 0x2d, 0x66, 0x0f, 0x05, 0xae, 0x87,
    0x5b, 0x2d, 0x21, 0x2d, 0xee, 0xa5, 0x0c, 0xfd, 0x80, 0xe8,
    0x92, 0x26, 0x02, 0x74, 0x1d, 0xc1, 0x74, 0x58, 0xb0, 0xc3,
    0x54, 0xed, 0x80, 0x12, 0x3f, 0xec, 0xcc, 0xbe, 0x06, 0x14,
    0xde, 0x62, 0x3e, 0xe1, 0x11, 0x19, 0x1d, 0x3e, 0x67, 0xe2,
    0xb6, 0x7e, 0x6b, 0x6e, 0x31, 0x33, 0x01, 0x03, 0xc0, 0xa7,
    0xf3, 0xb8, 0xa5, 0xb9, 0xe9, 0x5b, 0x29, 0xe8, 0x18, 0x5b,
    0x73, 0x50, 0xbe, 0x4d, 0x2b, 0xca, 0x6f, 0x1a, 0xb0, 0x33,
    0x21, 0x17, 0x44, 0x2e, 0x3b, 0xc3, 0x9f, 0x03, 0xeb, 0x02,
    0x10, 0x22, 0x22, 0x22, 0x22, 0x58, 0x17, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

  Crypto::Hash hash;

  getBinaryArrayHash(binaryArray, hash);

  std::string hashStr = Common::podToHex<Crypto::Hash>(hash);

  ASSERT_EQ("0f31384a7f42c564c3651a02a72918f34314baaddccdeec954b7794ebac3d8cb", hashStr);
}

// getBinaryArrayHash()
TEST(RpcServer, 2b)
{
  // this test is different than test 2 because we added 0x00 to end of binaryArray
  BinaryArray blockHeaderBA = 
  {
    {
      0x86, 0xd3, 0x7f, 0xb8, 0xf3, 0x72, 0x73, 0xce, 0x8, 0x71,
      0x3a, 0x60, 0xd4, 0xbc, 0x8f, 0xa3, 0xe8, 0xc1, 0x53, 0x1d,
      0x6a, 0x80, 0xb7, 0x30, 0x0, 0x5e, 0x4e, 0xfb, 0x5a, 0x86,
      0x8b, 0xec, 

      0xbf, 0x65, 0x55, 0x2d, 0x0, 0x0, 0x0, 0x0,
      
      0x2c, 0x24, 0xb0, 0x5b, 0x0, 0x0, 0x0, 0x0, 
      
      0x0f, 0x31, 0x38, 0x4a, 0x7f, 0x42, 0xc5, 0x64, 0xc3, 0x65, 0x1a, 0x02, 0xa7, 0x29, 0x18, 0xf3, 0x43, 0x14, 0xba, 0xad, 0xdc, 0xcd, 0xee, 0xc9, 0x54, 0xb7, 0x79, 0x4e, 0xba, 0xc3, 0xd8, 0xcb
    }
  };

  Crypto::Hash hash;

  getBinaryArrayHash(blockHeaderBA, hash);

  std::string hashStr = Common::podToHex<Crypto::Hash>(hash);

  ASSERT_EQ("00000000000c0032c7805c80ed14a8439bbee5df11b017714fd4101930408d75", hashStr);
}

int main(int argc, char** argv)
{
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}